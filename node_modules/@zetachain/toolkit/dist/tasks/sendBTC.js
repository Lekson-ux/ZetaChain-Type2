"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendBTCTask = void 0;
const confirm_1 = __importDefault(require("@inquirer/confirm"));
const networks_1 = require("@zetachain/networks");
const bitcoin = __importStar(require("bitcoinjs-lib"));
const dotenv = __importStar(require("dotenv"));
const ecpair_1 = __importDefault(require("ecpair"));
const config_1 = require("hardhat/config");
const ecc = __importStar(require("tiny-secp256k1"));
dotenv.config();
const decodeTransaction = async (tx) => {
    const API = (0, networks_1.getEndpoints)("blockcypher", "btc_testnet")[0].url;
    const p1 = await fetch(`${API}/txs/decode`, {
        body: JSON.stringify({ tx }),
        method: "POST",
    });
    return await p1.json();
};
const fetchUtxos = async (address) => {
    const API = (0, networks_1.getEndpoints)("esplora", "btc_testnet")[0].url;
    const response = await fetch(`${API}/address/${address}/utxo`);
    return response.json();
};
const makeTransaction = async (to, key, amount, utxos, address, m = "") => {
    const API = (0, networks_1.getEndpoints)("esplora", "btc_testnet")[0].url;
    const TESTNET = bitcoin.networks.testnet;
    const memo = Buffer.from(m, "hex");
    if (memo.length >= 78)
        throw new Error("Memo too long");
    utxos.sort((a, b) => a.value - b.value); // sort by value, ascending
    const fee = 10000;
    const total = amount + fee;
    let sum = 0;
    const pickUtxos = [];
    for (let i = 0; i < utxos.length; i++) {
        const utxo = utxos[i];
        sum += utxo.value;
        pickUtxos.push(utxo);
        if (sum >= total)
            break;
    }
    if (sum < total)
        throw new Error("Not enough funds");
    const change = sum - total;
    const txs = []; // txs corresponding to the utxos
    for (let i = 0; i < pickUtxos.length; i++) {
        const utxo = pickUtxos[i];
        const p1 = await fetch(`${API}/tx/${utxo.txid}`);
        const data = await p1.json();
        txs.push(data);
    }
    // try creating a transaction
    const psbt = new bitcoin.Psbt({ network: TESTNET });
    psbt.addOutput({ address: to, value: amount });
    if (memo.length > 0) {
        const embed = bitcoin.payments.embed({ data: [memo] });
        if (!embed.output)
            throw new Error("Unable to embed memo");
        psbt.addOutput({ script: embed.output, value: 0 });
    }
    if (change > 0) {
        psbt.addOutput({ address, value: change });
    }
    for (let i = 0; i < pickUtxos.length; i++) {
        const utxo = pickUtxos[i];
        const inputData = {};
        inputData.hash = txs[i].txid;
        inputData.index = utxo.vout;
        const witnessUtxo = {
            script: Buffer.from(txs[i].vout[utxo.vout].scriptpubkey, "hex"),
            value: utxo.value,
        };
        inputData.witnessUtxo = witnessUtxo;
        psbt.addInput(inputData);
    }
    for (let i = 0; i < pickUtxos.length; i++) {
        psbt.signInput(i, key);
    }
    psbt.finalizeAllInputs();
    return psbt.extractTransaction().toHex();
};
const main = async (args, hre) => {
    const TESTNET = bitcoin.networks.testnet;
    const API = (0, networks_1.getEndpoints)("blockcypher", "btc_testnet")[0].url;
    const pk = process.env.PRIVATE_KEY;
    const ECPair = (0, ecpair_1.default)(ecc);
    const key = ECPair.fromPrivateKey(Buffer.from(pk, "hex"), {
        network: TESTNET,
    });
    const { address } = bitcoin.payments.p2wpkh({
        network: TESTNET,
        pubkey: key.publicKey,
    });
    if (address === undefined)
        throw new Error("Address is undefined");
    const utxos = await fetchUtxos(address);
    const tx = await makeTransaction(args.recipient, key, parseFloat(args.amount) * 100000000, utxos, address, args.memo);
    const decoded = JSON.stringify(await decodeTransaction(tx), null, 2);
    console.log(`\nTransaction:\n\n${tx}\n`);
    console.log(`Decoded transaction:\n\n${decoded}\n`);
    await (0, confirm_1.default)({
        message: `Send ${parseFloat(args.amount)} tBTC to ${args.recipient}?`,
    }, { clearPromptOnDone: true });
    const p1 = await fetch(`${API}/txs/push`, {
        body: JSON.stringify({ tx }),
        method: "POST",
    });
    const data = await p1.json();
    const txhash = data?.tx?.hash;
    console.log(`Transaction hash: ${txhash}`);
};
exports.sendBTCTask = (0, config_1.task)("send-btc", "Deposit Bitcoin to and call contracts on ZetaChain", main)
    .addParam("recipient", "Address to send to")
    .addParam("amount", "Amount to send")
    .addOptionalParam("memo", "Memo to embed in transaction");
