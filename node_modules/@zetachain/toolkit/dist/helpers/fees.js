"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchFees = exports.fetchCCMFees = exports.fetchZEVMFees = void 0;
const getEndpoints_1 = require("@zetachain/networks/dist/src/getEndpoints");
const networks_1 = __importDefault(require("@zetachain/networks/dist/src/networks"));
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const formatTo18Decimals = (n) => parseFloat((0, utils_1.formatEther)(n)).toFixed(18);
const fetchZEVMFees = async (network) => {
    const url = (0, getEndpoints_1.getEndpoints)("evm", "zeta_testnet")[0].url;
    const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(url);
    const btcZRC20 = "0x65a45c57636f9BcCeD4fe193A602008578BcA90b"; // TODO: use getAddress("zrc20", "btc_testnet") when available
    const zrc20Address = network === "btc_testnet" ? btcZRC20 : (0, protocol_contracts_1.getAddress)("zrc20", network);
    if (!zrc20Address)
        return;
    const contract = new ethers_1.ethers.Contract(zrc20Address, ZRC20_json_1.default.abi, provider);
    const [, withdrawGasFee] = await contract.withdrawGasFee();
    const gasFee = ethers_1.ethers.BigNumber.from(withdrawGasFee);
    const protocolFee = ethers_1.ethers.BigNumber.from(await contract.PROTOCOL_FLAT_FEE());
    return {
        /* eslint-disable */
        totalFee: formatTo18Decimals(gasFee),
        gasFee: formatTo18Decimals(gasFee.sub(protocolFee)),
        protocolFee: formatTo18Decimals(protocolFee),
        /* eslint-enable */
    };
};
exports.fetchZEVMFees = fetchZEVMFees;
const fetchCCMFees = async (network, gas = 500000) => {
    const API = (0, getEndpoints_1.getEndpoints)("cosmos-http", "zeta_testnet")[0]?.url;
    if (!API) {
        throw new Error("getEndpoints: API endpoint not found");
    }
    const chainID = networks_1.default[network]?.chain_id;
    const url = `${API}/zeta-chain/crosschain/convertGasToZeta?chainId=${chainID}&gasLimit=${gas}`;
    const response = await (0, isomorphic_fetch_1.default)(url);
    const data = await response.json();
    const gasFee = ethers_1.ethers.BigNumber.from(data.outboundGasInZeta);
    const protocolFee = ethers_1.ethers.BigNumber.from(data.protocolFeeInZeta);
    return {
        /* eslint-disable */
        totalFee: formatTo18Decimals(gasFee.add(protocolFee)),
        gasFee: formatTo18Decimals(gasFee),
        protocolFee: formatTo18Decimals(protocolFee),
        /* eslint-enable */
    };
};
exports.fetchCCMFees = fetchCCMFees;
const fetchFees = async (gas) => {
    let fees = {
        feesCCM: {},
        feesZEVM: {},
    };
    const networkList = [...Object.keys(networks_1.default), "btc_testnet"];
    await Promise.all(networkList.map(async (n) => {
        try {
            const zevmFees = await (0, exports.fetchZEVMFees)(n);
            if (zevmFees)
                fees.feesZEVM[n] = zevmFees;
            const ccmFees = await (0, exports.fetchCCMFees)(n, gas);
            if (ccmFees)
                fees.feesCCM[n] = ccmFees;
        }
        catch (err) { }
    }));
    return fees;
};
exports.fetchFees = fetchFees;
