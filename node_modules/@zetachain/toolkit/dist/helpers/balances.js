"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBalances = exports.getSupportedChains = exports.getForeignCoins = void 0;
const ERC20_json_1 = __importDefault(require("@openzeppelin/contracts/build/contracts/ERC20.json"));
const getEndpoints_1 = require("@zetachain/networks/dist/src/getEndpoints");
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const getForeignCoins = async () => {
    const api = (0, getEndpoints_1.getEndpoints)("cosmos-http", "zeta_testnet")[0]?.url;
    const endpoint = `${api}/zeta-chain/fungible/foreign_coins`;
    const response = await (0, isomorphic_fetch_1.default)(endpoint);
    const data = await response.json();
    return data.foreignCoins;
};
exports.getForeignCoins = getForeignCoins;
const getSupportedChains = async () => {
    const api = (0, getEndpoints_1.getEndpoints)("cosmos-http", "zeta_testnet")[0]?.url;
    const endpoint = `${api}/zeta-chain/observer/supportedChains`;
    const response = await (0, isomorphic_fetch_1.default)(endpoint);
    const data = await response.json();
    return data.chains;
};
exports.getSupportedChains = getSupportedChains;
const getBalances = async (evmAddress, btcAddress = null) => {
    let tokens = [];
    const foreignCoins = await (0, exports.getForeignCoins)();
    const supportedChains = await (0, exports.getSupportedChains)();
    foreignCoins.forEach((token) => {
        if (token.coin_type === "Gas") {
            tokens.push({
                chain_id: token.foreign_chain_id,
                coin_type: token.coin_type,
                decimals: token.decimals,
                symbol: token.symbol,
                zrc20: token.zrc20_contract_address,
            });
            tokens.push({
                chain_id: 7001,
                coin_type: "ZRC20",
                contract: token.zrc20_contract_address,
                decimals: token.decimals,
                symbol: token.symbol,
            });
        }
        else if (token.coin_type === "ERC20") {
            tokens.push({
                chain_id: token.foreign_chain_id,
                coin_type: "ERC20",
                contract: token.asset,
                decimals: token.decimals,
                symbol: token.symbol,
                zrc20: token.zrc20_contract_address,
            });
            tokens.push({
                chain_id: 7001,
                coin_type: "ZRC20",
                contract: token.zrc20_contract_address,
                decimals: token.decimals,
                symbol: token.name,
            });
        }
    });
    supportedChains.forEach((chain) => {
        const contract = (0, protocol_contracts_1.getAddress)("zetaToken", chain.chain_name);
        if (contract) {
            tokens.push({
                chain_id: chain.chain_id,
                coin_type: "ERC20",
                contract,
                decimals: 18,
                symbol: "WZETA",
            });
        }
    });
    tokens.push({
        chain_id: 7001,
        coin_type: "Gas",
        decimals: 18,
        symbol: "ZETA",
    });
    tokens = tokens.map((token) => {
        const ticker = token.symbol.split("-")[0];
        const chain_name = token.chain_id === 7001
            ? "zeta_testnet"
            : supportedChains.find((c) => c.chain_id === token.chain_id)
                ?.chain_name;
        return {
            ...token,
            chain_name,
            id: `${token.chain_id
                .toString()
                .toLowerCase()}__${token.symbol.toLowerCase()}`,
            ticker,
        };
    });
    const balances = await Promise.all(tokens.map(async (token) => {
        const isGas = token.coin_type === "Gas";
        const isBitcoin = token.chain_name === "btc_testnet";
        const isERC = token.coin_type === "ERC20";
        const isZRC = token.coin_type === "ZRC20";
        if (isGas && !isBitcoin) {
            const rpc = (0, getEndpoints_1.getEndpoints)("evm", token.chain_name)[0]?.url;
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            return provider.getBalance(evmAddress).then((balance) => {
                return { ...token, balance: (0, utils_1.formatUnits)(balance, token.decimals) };
            });
        }
        else if (isGas && isBitcoin && btcAddress) {
            const API = (0, getEndpoints_1.getEndpoints)("esplora", "btc_testnet")[0]?.url;
            return (0, isomorphic_fetch_1.default)(`${API}/address/${btcAddress}`).then(async (response) => {
                const r = await response.json();
                const { funded_txo_sum, spent_txo_sum } = r.chain_stats;
                const balance = ((funded_txo_sum - spent_txo_sum) /
                    100000000).toString();
                return { ...token, balance };
            });
        }
        else if (isERC) {
            const rpc = (0, getEndpoints_1.getEndpoints)("evm", token.chain_name)[0]?.url;
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            const contract = new ethers_1.ethers.Contract(token.contract, ERC20_json_1.default.abi, provider);
            return contract.balanceOf(evmAddress).then((balance) => {
                return { ...token, balance: (0, utils_1.formatUnits)(balance, token.decimals) };
            });
        }
        else if (isZRC) {
            const rpc = (0, getEndpoints_1.getEndpoints)("evm", token.chain_name)[0]?.url;
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(rpc);
            const contract = new ethers_1.ethers.Contract(token.contract, ZRC20_json_1.default.abi, provider);
            return contract.balanceOf(evmAddress).then((balance) => {
                return {
                    ...token,
                    balance: (0, utils_1.formatUnits)(balance, token.decimals),
                };
            });
        }
        else {
            return Promise.resolve(token);
        }
    }));
    return balances;
};
exports.getBalances = getBalances;
