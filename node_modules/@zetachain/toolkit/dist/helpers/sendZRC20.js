"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendZRC20 = void 0;
const ERC20_json_1 = __importDefault(require("@openzeppelin/contracts/build/contracts/ERC20.json"));
const networks_1 = require("@zetachain/networks");
const networks_2 = require("@zetachain/networks");
const protocol_contracts_1 = require("@zetachain/protocol-contracts");
const ZRC20_json_1 = __importDefault(require("@zetachain/protocol-contracts/abi/zevm/ZRC20.sol/ZRC20.json"));
const ethers_1 = require("ethers");
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const sendZRC20 = async (signer, amount, network, destination, recipient, token) => {
    let value;
    try {
        value = ethers_1.ethers.utils.parseEther(amount);
    }
    catch (e) {
        throw new Error(`${value} is not a number and not a valid value for --amount, ${e}`);
    }
    const API = (0, networks_1.getEndpoints)("cosmos-http", "zeta_testnet")?.[0]?.url;
    const response = await (0, isomorphic_fetch_1.default)(`${API}/zeta-chain/fungible/foreign_coins`);
    const data = await response.json();
    const foreignCoins = data.foreignCoins;
    const networkChainID = networks_2.networks[network]?.chain_id;
    const foreignCoinsFiltered = foreignCoins.filter((coin) => {
        return coin.foreign_chain_id === networkChainID.toString();
    });
    let tx;
    if (network === "zeta_testnet") {
        const ZRC20Address = (0, protocol_contracts_1.getAddress)("zrc20", destination);
        const contract = new ethers_1.ethers.Contract(ZRC20Address, ZRC20_json_1.default.abi, signer);
        const value = ethers_1.ethers.utils.parseUnits(amount, 8);
        await (await contract.connect(signer).approve(ZRC20Address, value)).wait();
        const to = destination === "btc_testnet"
            ? ethers_1.ethers.utils.toUtf8Bytes(recipient)
            : signer.address;
        return await contract.connect(signer).withdraw(to, value);
    }
    else if (destination === "zeta_testnet") {
        const TSSAddress = (0, protocol_contracts_1.getAddress)("tss", network);
        const zrc20 = foreignCoinsFiltered.find((coin) => coin.symbol.toLowerCase() === token.toLowerCase());
        if (zrc20.coin_type.toLocaleLowerCase() === "erc20") {
            if (zrc20 === undefined) {
                throw new Error(`Token ${token} is not one of the available tokens to be deposited from ${network} to zeta_testnet`);
            }
            const erc20ContractAddress = zrc20.asset;
            const erc20TokenContract = new ethers_1.ethers.Contract(erc20ContractAddress, ERC20_json_1.default.abi, signer);
            const balance = await erc20TokenContract.balanceOf(signer.address);
            if (balance.lt(value)) {
                throw new Error("Insufficient token balance.");
            }
            const approveTx = await erc20TokenContract.approve(TSSAddress, value);
            await approveTx.wait();
            tx = await erc20TokenContract.transfer(TSSAddress, value);
        }
        else if (zrc20.coin_type.toLocaleLowerCase() === "gas") {
            tx = await signer.sendTransaction({
                to: TSSAddress,
                value,
            });
        }
        return tx;
    }
    else {
        throw new Error("Either --network or --destination should be zeta_testnet");
    }
};
exports.sendZRC20 = sendZRC20;
